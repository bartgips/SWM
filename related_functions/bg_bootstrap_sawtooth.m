function [stats]=bg_bootstrap_sawtooth(shapeMat, frac, numIt, lenFac, verbose, fignum)
% stats = bg_jackknife_sawtooth(shapeMat, frac, numIt, lenFac, verbose, fignum)
%
% Estimates confidence interval of skewness of noisy shapes contained in
% 'shapeMat' using bootstrap resampling.
%
% This method is useful when the individual shapes are very
% noisy, and this noise hinders you in determining the true skewness of
% every shape individually. Averaging over a larg enough (frac) sub sample,
% will average out most of the noise.
%
% Note: this method assumes a unimodal distribution of skewness.
% If the input is a result (a single cluster) from bg_SWM this is a
% fair assumption.
%
% %%%%%%%%%
% input:
% %%%%%%%%%
%
% shapeMat: Matrix of size numShapes x numTimepoints. E.g. the resulting
%           matrices from bg_swm_extract.
% 
% frac:     Fraction of total number of samples used every for every bootstrap
%           resample. (i.e. frac*numShapes is the amount of shapes in
%           every subsample)
% 
% numIt:    How many of these resampled distributions should be constructed
% 
% lenFac:   How many periods should the algorithm use to fit the sawtooth
%           (default = 1.2)
%
% verbose:  Flag that determines whether the progress (i.e. iteration
%           counter) is written to the terminal/ command window. 
%           (default: verbose = 1)
% 
% 
% fignum:   (optional) Figure number/handle to which to plot every sample with
%           its respective sawtooth fit. If left empty or set to zero, no
%           figure is plotted.
%
% %%%%%%%%%
% output:
% %%%%%%%%%
%
% stats:  a structure containing the calculated statistics:
%
% .mu:    Mean skewness
% .sem:   Estimated standard error of .mu
% .distr: Samples generated by the jackknife procedure that are used to
%         calculate .mu and .sem.

if nargin<4 || isempty(lenFac)
  lenFac=1.2;
end

if nargin<5
  verbose=1;
end
reverseStr=[];

if nargin >5 && fignum
  figure(fignum)
  clf
%   set(fignum,'visible','off')
end

fitOptions=optimset('Algorithm','interior-point','Display','off');

[numTemp, tempLen]=size(shapeMat);
skwIdx=nan(numIt,1);
period=skwIdx;
sampsz=round(frac*numTemp);


%% cut off sides of found shape (focus on centre of window +- x%; depends on lenFac)
% (for better fitting)
meanShapedum=nanmean(shapeMat);
meanShapedum=meanShapedum-nanmean(meanShapedum);

% Do a first fit to detect "phase"
lowerBound=[0; (tempLen/4); -(tempLen/2); -inf; -.999; -inf];
upperBound=[10; (tempLen*3/4); (tempLen/2); inf; .999; inf];

Xdum=[diff(minmax(nanmean(shapeMat)))/2, tempLen/2, 0, 0, 0, 0]';
[Xdum]=fmincon(@(x)sawtoothfit(meanShapedum,x),Xdum,[],[],[],[],lowerBound,upperBound,[],fitOptions);
shapeStart=mod(Xdum(3),Xdum(2));

if shapeStart > (tempLen/2)*0.85 % sawtooth is upside-down
  shapeStart=shapeStart-(1-Xdum(5))/2*Xdum(2);
end

brd=[shapeStart shapeStart+Xdum(2)]+[-1 1]*(lenFac-1)/2*Xdum(2);
brd=[max(floor(brd(1)),1) min(ceil(brd(2)),tempLen)];


stats.meanShape=nanmean(shapeMat)';
stats.swFit=nan*stats.meanShape;

% cut off extra bits
shapeMat=shapeMat(:,brd(1):brd(2));

%%
% intial fit parameters
X0=[diff(minmax(nanmean(shapeMat)))/2, tempLen/2, 0, nanmean(shapeMat(:)), 0, 0]';



for iter=1:numIt
  
  sel=ceil(rand(sampsz,1)*numTemp);
  meanShape=nanmean(shapeMat(sel,:))';
  
  if verbose
  msg=sprintf(['Iteration %d/%d\n'], [iter numIt]);
  fprintf([reverseStr, msg]);
  reverseStr = repmat(sprintf('\b'), 1, length(msg));
  end
  %% calculating SkwIdx
  
  %sawtoothfit  
  [X0]=fmincon(@(x)sawtoothfit(meanShape,x),X0,[],[],[],[],lowerBound,upperBound,[],fitOptions);
  skwIdx(iter)=X0(5);
  period(iter)=X0(2);
  
  if nargin >5 && fignum
    stdum=X0(1)*sawtooth(([1:numel(meanShape)]-X0(3))*2*pi/X0(2),(X0(5)+1)/2)+X0(4)+[1:numel(meanShape)]*X0(6);
    current_figure(fignum)
    plot(meanShape)
    hold on
    plot(stdum,'r')
    hold off
    title(sprintf(['Iteration %d/%d\n'], [iter numIt]))
    xlim([1 numel(meanShape)])
    drawnow
  end
  
end

% mean fit
meanShape=nanmean(shapeMat);
[X0]=fmincon(@(x)sawtoothfit(meanShape,x),X0,[],[],[],[],lowerBound,upperBound,[],fitOptions);
stdum=X0(1)*sawtooth(([1:numel(meanShape)]-X0(3))*2*pi/X0(2),(X0(5)+1)/2)+X0(4)+[1:numel(meanShape)]*X0(6);
stats.swFit(brd(1):brd(2))=stdum;

%% skewness
stats.skw.mu=mean(skwIdx);
stats.skw.sem=sqrt(numIt/(numIt-1)*var(skwIdx,1));
stats.skw.distr=skwIdx;


% perform t-test on difference from zero (only works if frac=1).
t=stats.skw.mu/stats.skw.sem;
stats.skw.p_t=1-tcdf(abs(t),numIt-1);
% 95% confidence
alpha=.05;
stats.skw.CI= quantile(skwIdx,[alpha/2 1-alpha/2]);

%% period
stats.period.mu=mean(period);
stats.period.sem=sqrt(numIt/(numIt-1)*var(period,1));
stats.period.distr=period;

% perform t-test on difference from zero (only works if frac=1).
t=stats.period.mu/stats.period.sem;
stats.period.p_t=1-tcdf(abs(t),numIt-1);
% 95% confidence
alpha=.05;
stats.period.CI= quantile(period,[alpha/2 1-alpha/2]);

function c=sawtoothfit(dat, lambda)
% c=sawtoothfit(dat, lambda)
% 
% calculated cost function of sawtooth with parameters 'lambda' compared to
% data.
% 
% lambda = [ amplitude; period; offset_x; offset_y; skewness; linear term];

dat=dat(:);
swth=lambda(1)*sawtooth(([1:numel(dat)]-lambda(3))*2*pi/lambda(2),(lambda(5)+1)/2)+lambda(4)+lambda(6)*[1:numel(dat)];
c=sum(((dat(:)-swth(:))).^2);

function current_figure(h)
set(0,'CurrentFigure',h)
